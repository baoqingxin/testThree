<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            list-style: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <script type="importmap">
        {
            "imports": {
                "three": "/node_modules/three/build/three.module.js",
                "three/addons/": "/node_modules/three/examples/jsm/",
                "load/": "/shader/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three'
        import {OrbitControls} from 'three/addons/controls/OrbitControls.js'

        const scene = new THREE.Scene()
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)

        camera.position.set(4, 4, 4)

        scene.add(camera)

        //创建环境光，环境光会均匀的照亮场景中的所有物体。
        const light = new THREE.AmbientLight(0x404040);
        //将环境光添加到场景
        scene.add(light);
        // 创建平行光
        const directionalLight = new THREE.DirectionalLight();
        //设置光源位置
        directionalLight.position.set(0, 5, 0);
        //添加到场景
        scene.add(directionalLight);
        //设置光源投射阴影
        directionalLight.castShadow= true

        // 创建渲染器
        const renderer = new THREE.WebGLRenderer();
        // 设置渲染器尺寸
        renderer.setSize(window.innerWidth, window.innerHeight);
        //开启渲染器阴影计算
        renderer.shadowMap.enabled = true
        //将canvas添加到body中
        document.body.appendChild(renderer.domElement);

        // 轨道控制器
        const controls = new OrbitControls(camera, renderer.domElement);
        // 轨道控制器的阻尼感
        controls.enableDamping = true;
        //辅助坐标轴
        const axesHelp = new THREE.AxesHelper();
        scene.add(axesHelp);

        const planeGeometry = new THREE.PlaneGeometry(3,3,64,64);

        const textureLoader = new THREE.TextureLoader();

        // const texture = textureLoader.load('/assets/aaa.png')
        // const texture = textureLoader.load('/assets/loginSzBG.png')
        const texture = textureLoader.load('/assets/a2.jpg')
        texture.colorSpace = THREE.SRGBColorSpace;

        // 顶点着色器代码
        const vertexShader = `
            uniform float time;
            varying vec2 vUv;

            void main() {
                float wave = sin(position.x * 10.0 + time) * 0.1;
                vec3 deformedPosition = position + vec3(wave, 0.0, 0.0);

                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(deformedPosition, 1.0);
            }
        `;

        // 片段着色器代码
        const fragmentShader = `
            uniform sampler2D uTexture;
            varying vec2 vUv;

            void main() {
                gl_FragColor = texture2D(uTexture, vUv);
            }
        `;

        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                uTexture: { value: texture }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader
        });

        // const material = new THREE.MeshPhongMaterial({ color: 0xffffff * Math.random(), flatShading: true })
        // const material = new THREE.MeshBasicMaterial( { map: texture } );

        const plane = new THREE.Mesh(planeGeometry, material);
        plane.rotation.x = -Math.PI / 2; // 平面水平放置
        scene.add(plane);

        renderer.setClearAlpha(0);// 数值为0.7就是半透明

        const clock = new THREE.Clock()
        //渲染函数
        function render() {
            //阻尼
            controls.update()
            let time = clock.getElapsedTime();
            // material.uniforms.uTime.value = time
            material.uniforms.time.value = time

            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }

        // 初始化渲染函数
        render();

        // 监听浏览器窗口尺寸变化
        window.addEventListener('resize',() => {
            //重新设置相机宽高比
            camera.aspect = window.innerWidth / window.innerHeight;
            //更新相机投影矩阵
            camera.updateProjectionMatrix();
            //重新设置渲染器尺寸
            renderer.setSize(window.innerWidth,window.innerHeight);
            //设置设备像素比
            renderer.setPixelRatio(window.devicePixelRatio)
        })

    </script>
</body>
</html>